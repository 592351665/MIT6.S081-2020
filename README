mmap（memory map）允许将一个文件或设备中的一部分内容映射到进程的虚拟地址空间，当文件映射成功后，进程可以直接通过指针访问文件内容，而无需再调用系统的 I/O 函数，这种方式提高了文件访问的效率。

1.xv6的虚拟地址空间与linux不同，堆在栈的上面，且堆向上增长；我们选择将 mmap 映射进来的文件 map 到尽可能高的位置，也就是刚好在 trapframe 下面。并且若有多个 mmap 的文件，则向下生长。

2.sys_mmap:

for循环最后得到的vaend，是已使用的地址最低的vma槽的起始地址，也是找到空槽的结束地址；

3.readi：从文件中读内容到物理地址
第一个参数：指向文件inode结构体的指针；

第二个参数user_dst：目标地址dst是用户空间还是内核空间（0）；

第三个参数dst：目标地址；

第四个参数：文件中的偏移量，计算文件中的实际读取位置；

v->offset+PGROUNDDOWN(va-v->addr)

v->offset 表示文件映射的起始偏移量，

va - v->addr 虚拟地址 `va` 相对于 `vma` 起始地址的偏移量

可以这样理解：v->offset表示只将文件中的部分内容映射到vma中，但此时我们要从va虚拟地址开始读，从vma到va这部分就不需要读， 所以文件中实际读取位置是：

v->offset+PGROUNDDOWN(va-v->addr)，PGROUNDDOWN：向下对齐，向低地址对齐；

第五个参数：要读取数据的大小，4096字节=4K，一页；

4.将虚拟地址映射到物理内存，并设置权限：

`v->prot` 是 `vma` 的保护标志，表示该内存区域的访问权限；通过|= 给perm增加内容；

5.函数vmatrylazytouch定义在sysfile.c文件中，被调用在trap.c中，需要有函数生声明，把int vmatrylazytouch(uint64 va)加在defs.h中；

6.sys_munmap:

删除指定地址范围内的`mmap`映射;

addr>v->addr && addr+sz<v->addr+v->sz：防止空洞产生，vma中页是从低地址向高地址填充？？ addr>v->addr表示不从头，addr+sz<v->addr+v->sz表示不靠尾，是中间一段，会产生空洞；

int nummap = sz-(addr_aligned-addr)：释放起始地址向上对齐，确保被截断的页不会释放；

vmaunmap解除部分映射后，要修改vma的offset,sz,addr等：如果是头部unmap，在文件中对应偏移改变，v->addr变高；


7.函数vmaunmap：

作用：解除vma对应部分的映射，并释放相关的物理内存。如果映射的内容被修改过（即“脏页”），并且是共享映射（`MAP_SHARED`），还需要将数据（物理内存）写回到磁盘文件中

1）aoff < 0的情况：第一页一半在vma内，一部分不在，我们只需要把在vma的部分写回磁盘即可；

从pa + (-aoff)写PGSIZE + aoff大小到文件对应位置；

2）aoff+PGSIZE > v->sz：最后一页超出了vma，只将在vma的前部分写回文件；

3）中间页：整页写回到文件对应位置；

8.报错：
In file included from kernel/vm.c:9: kernel/proc.h:98:19: error: field 'lock' has incomplete type 98 | struct spinlock lock; | ^~~~ In file included from kernel/vm.c:10: kernel/file.h:21:20: error: field 'lock' has incomplete type 21 | struct sleeplock lock; 

实现解除映射、释放物理内存并对脏页进行写回这部分功能，用到walk函数，该函数在vm.c中，同时为了增强复用性；

因为用到了vma和file结构体，所以应包含对应头文件；运行就会报上面错误，再尝试加入自旋锁和睡眠锁的头文件，因为加在了后面，所以依旧报错，要加载前面，注意头文件的依赖关系；
